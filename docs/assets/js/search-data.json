[{"doc":"This page has not yet sprouted","title":"This page has not yet sprouted","hpath":"403","content":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","url":"https://aneri12345.github.io/Personal-Log/notes\\403.html","relUrl":"notes\\403.html"},{"doc":"Root","title":"Root","hpath":"root","content":"# Welcome to Dendron\n\nThis is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top. \n","url":"https://aneri12345.github.io/Personal-Log","relUrl":"/"},{"doc":"Courses","title":"Courses","hpath":"Courses","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\16jEZVVz0jb3JFwU1QZyi.html","relUrl":"notes\\16jEZVVz0jb3JFwU1QZyi.html"},{"doc":"Sem-5","title":"Sem-5","hpath":"Courses.Sem-5","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\0dq74Ji6Sqc5B99r7PET2.html","relUrl":"notes\\0dq74Ji6Sqc5B99r7PET2.html"},{"doc":"OS","title":"OS","hpath":"Courses.Sem-5.OS","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\gtn0zBIfNeLMHtBLq4skY.html","relUrl":"notes\\gtn0zBIfNeLMHtBLq4skY.html"},{"doc":"Notes","title":"Notes","hpath":"Courses.Sem-5.OS.Notes","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\bbBsU0WVTftvnCT4UDrAT.html","relUrl":"notes\\bbBsU0WVTftvnCT4UDrAT.html"},{"doc":"Lec 6","title":"Lec 6","hpath":"Courses.Sem-5.OS.Notes.Lec 6","content":"## Recap\n![](2021-09-12-08-54-36.png)\n\n# Process Control and Process Management\n\n> Process management will be studied in UNIX SVR4 file system.\n\n## Functions of OS kernel\n* ![](2021-09-12-08-58-24.png)\n* ![](2021-09-12-09-00-09.png)\n* ![](2021-09-12-09-01-14.png)\n\n## Process Creation\n* Once new process is decided to be created, OS performs following tasks\n    * Assigning unique ID.\n    * Allocating space in memory.\n    * Initializing PCB (The most important part of a process).\n    * Setting up of appropriate links.\n    * Creating or expanding other data structures.\n\n## Process Switching\n* For small amount of time, some process will run and then other will run. This time is very small and hence we see it like all the processes are running parallely.\n* Thus, when one process goes away and other process needs to be loaded, this is called process switching.\n* Process switching is totally different than mode switching. In a process execution, there may occur mode switching. \n* Mode switching means switching from user to kernal mode vice versa.\n\n> So why is process gets switched?\n* ![](/assets/images/2021-09-06-08-23-14.png)\n\n* Reasons for switching (Eg.)\n    * Clock interrupt (time slice expired)\n    * I/O Interrupt (an event occured)\n    * Memory fault (trap) - Accessing memory which is not available.\n\n* Mode Switching - When a running process changes its mode from one to other.\n    * While switching the mode, processor state information of PCB is saved (user to kernel) and restored back (kernel to user).\n    * Mode switch, thus becomes the subset of prcess switch.\n    * Thus, process switch will take more time then mode switch.\n* Steps in process switch\n    * ![](/assets/images/2021-09-06-08-28-44.png)\n\n> Is OS a process?\n* Basically OS is a code/program which is in between hardware and application that we run.\n* Designs of OS to explain execution of OS\n    * ![](/assets/images/2021-09-06-08-33-06.png)\n\n## Different designs\n* Non-process Kernel\n* Execution within User Processes\n    * ![](/assets/images/2021-09-06-08-36-42.png)\n* Process-based OS\n    * ![](/assets/images/2021-09-06-08-37-48.png)\n    * More like microkernel architecture.\n\n## Process management in UNIX SVR4\n* SVR4 stands for System V Release 4.\n* **Most** of the the OS executes in user process.\n* System processes - Kernel mode only\n* User Processes\n    * User mode to execute user programs and utilities.\n    * Kernel mode to execture instructions that belong to kernel\n* Process with ID 1 = Linux boots and creates a swapper process which in turn creates init process with ID = 1.\n* This init process creates all the process required to run Linux on boot up.\n* init process works only in kernel mode.\n* Some other process that execute only in kernel mode include dispatcher etc.\n* States\n    * ![](/assets/images/2021-09-06-08-47-29.png)\n    * Fork is the system call used to create new process.\n    * Two extra states\n    * Blocking state is called sleep state.\n    * Zombie state means that process is executed but some imformation realted to data structure and all is still saved for accounting purposes.\n    * Here running state is divided into two parts viz user running state and kernel running state.\n    * At a time, a process can be in either user running state or kernel running state but **not both.**\n    * Preempted is almost similar to ready to run in memory state. In fact they are managed by a common combined queue.\n* UNIX Process Image\n    * A process in UNIX is a set of DS that provide the OS with all the information necessary to manage and dispatch processes.\n    * Process image in UNIX can be categorized as follows\n        * User-Level Context\n            * ![](/assets/images/2021-09-09-11-14-50.png)\n        * Register Context\n            * ![](/assets/images/2021-09-09-11-15-08.png)\n        * System-Level Context\n            * ![](/assets/images/2021-09-09-11-15-54.png)\n            * Most of the information regarding PCB is maintained in process table and they **must be accessible to kernel.**\n            * U Area - Most of the process control information is present in U area. This is also a part of PCB. However, majority of information related to PCB is present in Process table.\n            * Information in U area is accessible to a process only if it is in running state.\n            * 1st and 3rd are static DS means they will not change during the life of a process.\n            * 2nd and 4th are dynamic data structure and will change according to various states of the process.\n* Process Creation in UNIX\n    * fork() is used to create new processes.\n    * ![](/assets/images/2021-09-09-11-26-30.png)\n    ![](/assets/images/2021-09-09-11-27-38.png)\n    * If returned value is 0, it means it is child process and vice versa.\n    * Once child is created, then it depends on the situation which one will execute.\n            \n## Extra Points\n> What is in process table?\n* ![](/assets/images/2021-09-09-11-22-44.png)\n\n> What is in U area?\n* ![](/assets/images/2021-09-09-11-23-18.png)","url":"https://aneri12345.github.io/Personal-Log/notes\\275oHnSOurASwRFVYefgE.html","relUrl":"notes\\275oHnSOurASwRFVYefgE.html"},{"doc":"Lec 1","title":"Lec 1","hpath":"Courses.Sem-5.OS.Notes.Lec 5","content":"\n\n## Suspended Process (5-state)\n* It is possible that at one point _all the processes are waiting_ for I/O and processor will remain idle.\n* Issues to address\n    * Processor could be idle most of the time.\n* Solution\n    * **Swap these processes to disk to free RAM and execute some new processes**.\n* Blocked state, thus, becomes suspend state when swapped to disk.\n* Now 5-state gets converted to 6-state model\n\n## 6-state model\n* ![](2021-09-11-16-27-42.png)\n* Notice that blocked processes are transferred to suspended processes BUT suspened processes are **directly** transfered to ready state.\n* OS now has two ways to bring process in main memory\n    * Admit new processes\n    * Activate previously suspended processes\n* Subsets of suspend state\n    * Blocked/Suspend: Process in secondary memory and awaiting an event.\n    * Ready/Suspend: In secondary mem but available for execution as soon as brought in main memory\n\n## 7-state model\n* ![](2021-09-11-16-36-47.png)\n* If memory is not available, new process can be admitted into ready/suspended memory\n* Newly created process will remain in ready/suspend state until there is memory avaible to move it to ready state.\n* Eg. When booting up, memory is awailable and hence it is possible to directly admit new process into ready state.\n* New state transitions\n![](2021-09-11-16-37-37.png)\n* Block suspend to block: then OS thinks that higher priority block suspend process id going to happen in near future, it will bring BS process to B\n\n## Characterisitcs of suspended processes\n* Process not immediately available for execution because \n    * No enough mem to bring in ready state from ready suspend\n    * Is in block suspend state\n* It may or may not be waiting for an event(RS or BS states)\n* \"Agent\" puts the process in suspended state. Agents include either itself (Eg. Some process which occur only periodically), parent procees or OS in order to preclude its execution.\n* Process may not be removed until agent orders the removal. Most of the time agent is OS.\n\n## Reason for process suspension\n* ![](2021-09-11-17-17-03.png)\n\n## Relation between process and resource\n> Recap: OS is a resource manager. Process is a program in execution.\n![](/assets/images/2021-09-11-17-45-05.png)\n* **Main memory is also a resource means**\n* Virtual memory is extention of secondary memory into main memory.\n* Some part of HDD is considered in RAM.\n\n# Data Structures for OS\n* OS must have information about current status and all processes and all resources.\n* Thus, OS maintains tables for each of the functionalities it offers\n## Memory Table\n* Keep tracks of main and secondary memory.\n* Must include information\n    * Allocation of main memory to processes.\n    * Allocation of secondary memory to processes.\n    * Protection attributes for access to shared memory regions.\n    * Information required to manage virtual memory.\n## I/O Table\n* Manage I/O device and channels of computer.\n* Must include information\n    * Availability of I/O device.\n    * Status of I/O operation whether I/O device is available or not.\n    * Location in main memory for source and destination\n## File Table\n* Must include information\n    * Existence of files.\n    * Location on secondary memory.\n    * Current Status.\n    * Others (Who can access? Readable or writable? etc.)\n## Process Table\n* Must include information\n    * Location of **process** in the memory.\n    * Process attributes.\n* Memory, I/O and files are managed on behalf of processes, so there has to be some reference to these resources in process tables. (Like foreign key)\n\n____________________________________________________________________________\n\n## Physical manifestation of a process\n> Menifestation means presentation.\n![](/assets/images/2021-09-11-17-55-10.png)\n\n* Elements of **Process Image** aka memory\n    * User Data\n    * User Program\n    * User Stack\n    * Process Control Block (PCB)\n\n## Process Location\n* It is not required in main memory. Someting called virtual memory also exists.\n* Process image is maintained as a contiguous block of memory (**in secondary memory**) \n    * **_EXCEPT_** PCB it is in main memory.\n* Maintained in secondary memory (majority of its part).\n* Some part should be loaded in main or at least in virtual memory.\n* Moreover, to execute process, program must be in main memory even in pages form.\n* Thus OS needs to know which parts of process are in main and secondary memory and at which location.\n> Paging system: The memory is divided into chunks\n\n## 3 general Attributes in PCB\n* Process identification\n* Processor state information\n* Process control information\n\n## Process Identification\n* Identifier of this process.\n* Identifier of parent process.\n* User identifier (To which user this process belongs to?)\n\n## Processor state information\n> Processor state is always **stored in register.**\n\n* User Visible registers\n    * Most of the times they are the address registers and data registers\n    * It means that these registes can be directly visible by programs running in user-mode.\n    * Generally they are 8-32 regsiters but some RISC implementations may have over 100.\n* Control and status registers\n    * Program counter - Contains address of the next instruction.\n    * Condition codes - Result of the most recent ALU operation.\n    * Status information - Contains inturrept flags and execution mode (They are also known as program/process status mode).\n* Stack Pointers (Registers)\n    * Process image uses stack to maintain parameters and calling addresses for procedures and system calls.\n    * There could be multiple stacks and each stack has a stack pointer pointing to the top of the stack.\n\n## Process control information\n> Manages additional information that is needed by the OS to control and coordinate the various active processes.\n\n* These include the following\n    1. Scheduling and state information\n    2. Data Structuring\n    3. IPC - Inter-process communication\n    4. Process Privilleges\n    5. Memory Management\n    6. Resource Ownership and Utilization \n    * Process privileges includes \"What area can be accessed by the process\" or \"Which mode?\" etc.\n* Scheduling and State information\n    ![](/assets/images/2021-09-11-18-17-00.png)\n* Data Structuring\n    * ![](/assets/images/2021-09-11-18-17-22.png) \n    * For each state (blocked, ready etc.) there would be one queue and generally they are made using linked list.\n* IPC\n    * ![](/assets/images/2021-09-11-18-20-39.png)\n    * It occurs when two process talk to each other\n* Process privileges\n    * ![](/assets/images/2021-09-11-18-21-09.png)\n    * What kind of file, area of memory etc.\n* Memory Management\n    * ![](/assets/images/2021-09-11-18-23-59.png)\n* Resource Ownership and Utilization\n    * ![](/assets/images/2021-09-11-18-24-44.png)\n> ## What does Process image contain?\n* ![](/assets/images/2021-09-11-18-38-28.png)\n\n## Role of PCB\n* It is the most important DS.\n* It contains most of the information regarding a process excpet stack pointers.\n* It manages the processes.\n* Thus, it requires protection.\n    * If not done then,\n        * It may damage the block and destroy OS's ability to manage the processes.\n        * Any change in design will affect many other modules of OS.\n\n","url":"https://aneri12345.github.io/Personal-Log/notes\\2HwzsBwwTFWYs5fV9TNd9.html","relUrl":"notes\\2HwzsBwwTFWYs5fV9TNd9.html"},{"doc":"OS","title":"OS","hpath":"Courses.Sem-5.OS.Notes.Lec 4","content":"\n\r\n\r\n# Process: Description and Control\r\n\r\n4 imp functions of os\r\n* File management\r\n* Memory management\r\n* Process management - Fundamental task\r\n* IO management \r\n\r\n## Requirements of OS as a Process Manager\r\n* Interleave the execution of multiple processes. Here we assume that there is always a single processor system.\r\n* Allocate resources to processes and protect them from each other especially in the case where both processes are using same files, to avoid any clashes.\r\n* Enable process to share and exchange information. Eg. Parent and Child processes.\r\n* Enable synchronization among processes.\r\n\r\n## What is a Process?\r\n* Program in execution.\r\n* Instance of program running\r\n* Entity that can be assigned to and executed on a processor\r\n* **Unit of activity characterized by the execution of a sequence of instructions, a current state and an associated set of resources**\r\n* Process Elements\r\n    * Program code (generally shared)\r\n    * Set of data\r\n    * Attributes that describes the state\r\n    \r\n## Attributes - maintained in PCB\r\n* Indentifier - Unique ID of each process\r\n* State - Current situation of the process (Either running or not running)\r\n* Priority - Self explanatory\r\n* Program Counter - Keeps information about next process to be executed\r\n* Memory pointers - Pointers to program code and data to be processed. Along with this, it also includes shared memory blocks.\r\n* Context data\r\n* I/O status information - Eg. List of files in use by the process etc.\r\n* Accounting information - Eg. Time limits, clocks used etc.\r\n\r\n> _In short the attributes can be called as meta-data_ (things apart from the program and data, these are the things which manage and drive the process).\r\n\r\n## Process Control Block (PCB)\r\n* All the attributes discussed above are maintained in this block.\r\n* Basically, it is a type of data structure.\r\n\r\n> **Thus, process is a combination of program code, associated data and PCB**\r\n\r\n## Running on single resource\r\n* To manage multiple processes on a single resources then scheduling comes to the picture.\r\n* Thus, you allocate certain span of time to each process and once it gets finished, immediately another process starts.\r\n* It gives an appearance that every process runs at the same time because the total time taken by all the process combined is really small.\r\n* **Trace - List of instructions that are executed by a process.**\r\n* **Dispatcher - Program that switches the processor from one process to another.** It is a type of short term scheduler.\r\n\r\n## Execution of Processes by Processor\r\n* Suppose that there are some processes which have a lot of instructions to execute. This might take time which is greater than the allocated one.\r\n* So in the middle of the execution of a process, dispatcher stops the execution and decides which process should go next.\r\n* Once decided, either execution of new process starts or execution of old process continues.\r\n* Then, suppose there is an I/O request. Since this is a slow operation, the dispatcher will allow another process to run on the processor.\r\n* This goes on and on untill all the processes are executed.\r\n\r\n> The above method is from **processor POV** and is called **interleaving of processes** and the OS manages this through **dispatcher**. From **process POV**, the process gets executed sequencially.\r\n\r\n## Process States\r\n* Two states\r\n    * Running\r\n    * Not running\r\n* Transition from **not running** to **running** state is called **dispatch** and is called **pause** for the opposite scenario.\r\n* There can be at most only one process in running state at a given instance of time.\r\n* There are 'n' number of processes in the non-running state.\r\n* Thus, to manage all these processes, we need **queue** as the data structure.\r\n\r\n## Note\r\n* The below picture lists conditions under which a process can be created or terminated.\r\n![](/assets/images/2021-09-10-23-18-55.png)\r\n* Process spawning means event where a process creates a new process.\r\n\r\n## 5-State Process Model\r\n* Conditions when the process which is running will pause and enter in the queue:\r\n    * Time slot alloted to the process is over.\r\n    * Made some I/O request which may take time.\r\n* Now, dispatcher needs to identify which processes are ready to be executed and then_ dispatch it from the middle of the queue._ This process is **time consuming and complex.**\r\n* **Solution:**  OS must maintain multiple queues. Since there are two types of processes\r\n    * Waiting - one who did not terminate but their allocated time got over and others who are waiting for I/O or other resouces.\r\n    * Others that are ready to be dispatched and timeout ones (alloted time is over).\r\n*  _**This, in turn is the 5-state process model.**_\r\n* Total states in this model\r\n    1. New - Process that has just been created but not admitted to the pool of the ready state processes.\r\n        * **Not loaded in main memory but is created.**\r\n        * This means that PCB for that process has been created but its corresponding data and program has not been loaded/created in the main memory.\r\n    2. Ready - DS: queue\r\n    3. Blocked/Waiting - DS: queue\r\n    4. Running \r\n    5. Exit (Earlier it was not a state but now it is) - Process which has been released from the pool of processes.\r\n        * However, there is some part of PCB left in main memory for accounting.\r\n\r\n![](/assets/images/2021-09-11-11-43-14.png)\r\n\r\n## State Transitions\r\n\r\n![](/assets/images/2021-09-11-11-51-30.png)\r\n\r\n* Ready and Blocked process can enter directly to exit state when its parent process has terminated or the process is terminated by the OS.\r\n* When process spawning occurs, then child process is created in the new state.\r\n* Hang state is equivalent to blocked/waiting state. If we remove it, it is directly moved to exit from ready state.\r\n![](/assets/images/2021-09-11-11-54-33.png)\r\n* **Problems** - \r\n    * Suppose there are 10 processes which are in blocked queue waiting for HDD to get accesible and there are 90 processes that are in hang mode.\r\n    * Now once HDD is ready to be accessed, OS will have to search this blocked queue and move all these processes to ready state.\r\n    * This is again time consuming and complex. Hence **multiple blocked queue model emerged**.\r\n\r\n\r\n## Multiple Blocked Queue\r\n![](/assets/images/2021-09-11-11-57-07.png)\r\n","url":"https://aneri12345.github.io/Personal-Log/notes\\tFy23OlAvEHgWWoRF2db5.html","relUrl":"notes\\tFy23OlAvEHgWWoRF2db5.html"},{"doc":"MUS","title":"MUS","hpath":"Courses.Sem-5.MUS","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\bEXJtcG0DruZFBjeZLo1P.html","relUrl":"notes\\bEXJtcG0DruZFBjeZLo1P.html"},{"doc":"Notes","title":"Notes","hpath":"Courses.Sem-5.MUS.Notes","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\ZhmNN5nt1w5v9MtifbuE7.html","relUrl":"notes\\ZhmNN5nt1w5v9MtifbuE7.html"},{"doc":"Vivieck Rajgopalan","title":"Vivieck Rajgopalan","hpath":"Courses.Sem-5.MUS.Notes.Guest","content":"\n# Session with Viveick Rajgopalan\r\n\r\n\r\n* Music is not an individual frequency but a collective form. \r\n    * Just like we cannot see whats inside any human body(the whole anatomy behind)\r\n* Why is there a need of mathematics and science for music?\r\n   * We need to impact correctly in our multiple listners accurately\r\n   * It is like flying a plane, we need to have knowledge about all the variables.\r\n> _Music is not about perfection, but the recognition of ones errors makes the difference. It is important to be persistent(Sadhna)._\r\n\r\n## Ta Dhoom\r\n* Ta Dhoom - https://www.youtube.com/watch?v=cw0dI8RZcNM\r\n* The key to progress is to observe/ copy and learn.\r\n* Classes were taken for 2 hrs for 8 months to the students understand phrasing and rythm better.\r\n* Literacy was focused instead of education \r\n* It was an inspiration to India 91\r\n    * India 91 - https://www.youtube.com/watch?v=9duqDXBXBJ8\r\n> \"_I lived the dream_\" ~Vivieck Rajgopalan\r\n\r\n## Feeling the tempo: \r\n* Singing along with clapping helps to maintain rythm and gives measure to each interval between a clap.\r\n* Each clap is said to be a dot.\r\n### The sing alongs:  \r\n* 5 dots - Ta ka ta ki t \r\n* 4 dots - Ta ka dhi mi\r\n* 3 dots - Ta ki ta\r\n* 16 odts - Adi tala\r\n* Konnakol: Different phases along with dot manipulations is used in\r\n## Visualizing things\r\n* Yatis\r\n![](/assets/images/2021-09-09-12-29-03.png) \r\n![](/assets/images/2021-09-09-12-31-20.png)\r\n* Yatis helps us visualize things \r\nEg of Mridanga Yati\r\nhttps://www.youtube.com/watch?v=h0VReJLLbAE&list=PLRG-uGa5ZLuGF-WgZ882APLBYocPfGQhW&index=2\r\n* **_Formless represents the beauty and not the chaos_**\r\n* According to mathematical perception, the beats seem converging towards the end and later diverges with a start.\r\n\r\n> _It is very important for a mucisian - be persistent _\r\n> The sequence to a music: beats grabs ones attention, while thats not it. The listeners hold on to the music/song through the lyrics.\r\n","url":"https://aneri12345.github.io/Personal-Log/notes\\9Zj8aZLwlI6Tr6qHOWRRf.html","relUrl":"notes\\9Zj8aZLwlI6Tr6qHOWRRf.html"},{"doc":"MSE","title":"MSE","hpath":"Courses.Sem-5.MSE","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\RENT41HZ7tBYu7kQlwqsP.html","relUrl":"notes\\RENT41HZ7tBYu7kQlwqsP.html"},{"doc":"IDTB","title":"IDTB","hpath":"Courses.Sem-5.IDTB","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\RekrWYfJI7kuXr4zvKuNt.html","relUrl":"notes\\RekrWYfJI7kuXr4zvKuNt.html"},{"doc":"Notes1","title":"Notes1","hpath":"Courses.Sem-5.IDTB.Notes","content":"\n## Psycology\n* The science of behaviour and mind \n* Application of science to solve human problems\n* Feelings - unobservable | Behaviour - observable actions\n* Science is gaining knowledge by observation and experimentation\n## Structuralism\n* Break down into its constituent elements (sensation/emotions/feelings)\n* Method: Introspection\n* What questions: \"What were you feeling\"\n* **Problems**  \n    * Got all elements but cannot comphrehend well about the function.\n## Functionalist\n* mind and behaviour is adaptive(perp for exam/ playing..)\n* How learning/ memory happens\n* Why questions\n* **Problems**  \n    * No scientific method to determine/ observe mind\n## Behaviorism\n* Observe - Experiment - Analyse\n* Should study behaviour instead of mind\n* 3 beliefs of behaviouralist\n    * Complex behavious are orn from the pre elementry knwledge\n    * Focus on learnd behviour not inbuilt \n    * humans and animals are same\n* **Problems**\n    * Focuses onnly on behaviour, whats inside mind is missed out \n## Gestalt psycologist \n* Mind works as whole and not in parts\n* Mind triesto find patterns\n![](2021-09-05-00-31-03.png)\n## Organisational Behaviour Model\n* Framework: Input, Process, Output\n* EG:  \n    * **Individual level:** Humans are the inputs, feelings/emotions are process, output is our work\n    * **Group Level:** coordination etc\n    * **Organisation level:** culture, structure\n    ![](2021-09-05-11-51-39.png)\n    ![](2021-09-05-11-54-58.png)\n## Learning\nRelatively permenant change in ones behaviour due to an experience(affecting ones sensory systems)\n## Classical conditioning\n* Conditioned Stimulus - condition that accompanies natural stimulus\n* Unonditioned Stimulus - natural event\n* Conditioned Response - behaviour for conditioned stimulus\n* Unconditioned Response - how do we react naturally\n## Operant Conditioning\n* Behvaiour is function of consequences\n## Social Learning Theory\n* Individuals learn by observing others and gaining experiencing   \n* **Vicarious reinforceents** - Not necessary to behave in perticular manner to know output, you can observe and and reinforce some actions\n* People respond on how they percieve and define consequences NOT to the objective consequences. **_Can be different_**\n## Johari window\n![](2021-09-06-08-29-17.png)\n![](2021-09-06-08-29-42.png)\n![](2021-09-06-08-30-03.png)\n![](2021-09-06-08-30-19.png)\n## Piaget's Theory\n* Children learn by exploring and playing","url":"https://aneri12345.github.io/Personal-Log/notes\\w51gdQ0gRcuJd6eSUMSdf.html","relUrl":"notes\\w51gdQ0gRcuJd6eSUMSdf.html"},{"doc":"HRT","title":"HRT","hpath":"Courses.Sem-5.HRT","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\xiErRf1bVjQPmQ41FUeuc.html","relUrl":"notes\\xiErRf1bVjQPmQ41FUeuc.html"},{"doc":"Notes","title":"Notes","hpath":"Courses.Sem-5.HRT.Notes","content":"\n","url":"https://aneri12345.github.io/Personal-Log/notes\\LsHHhkPa6BNZjK5uG7rUZ.html","relUrl":"notes\\LsHHhkPa6BNZjK5uG7rUZ.html"},{"doc":"Lec 1","title":"Lec 1","hpath":"Courses.Sem-5.HRT.Notes.Lec 1","content":"","url":"https://aneri12345.github.io/Personal-Log/notes\\6vvbxsElxUbey7mGzXVsq.html","relUrl":"notes\\6vvbxsElxUbey7mGzXVsq.html"},{"doc":"Changelog","title":"Changelog","hpath":"root.changelog","content":"","url":"https://aneri12345.github.io/Personal-Log/notes\\changelog.html","relUrl":"notes\\changelog.html"}]
